// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: snakes.proto

package gogofast

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Роль узла в топологии связей узлов в пределах игры
type NodeRole int32

const (
	NodeRole_NORMAL NodeRole = 0
	NodeRole_MASTER NodeRole = 1
	NodeRole_DEPUTY NodeRole = 2
	NodeRole_VIEWER NodeRole = 3
)

var NodeRole_name = map[int32]string{
	0: "NORMAL",
	1: "MASTER",
	2: "DEPUTY",
	3: "VIEWER",
}

var NodeRole_value = map[string]int32{
	"NORMAL": 0,
	"MASTER": 1,
	"DEPUTY": 2,
	"VIEWER": 3,
}

func (x NodeRole) Enum() *NodeRole {
	p := new(NodeRole)
	*p = x
	return p
}

func (x NodeRole) String() string {
	return proto.EnumName(NodeRole_name, int32(x))
}

func (x *NodeRole) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NodeRole_value, data, "NodeRole")
	if err != nil {
		return err
	}
	*x = NodeRole(value)
	return nil
}

func (NodeRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{0}
}

// Тип игрока
type PlayerType int32

const (
	PlayerType_HUMAN PlayerType = 0
	PlayerType_ROBOT PlayerType = 1
)

var PlayerType_name = map[int32]string{
	0: "HUMAN",
	1: "ROBOT",
}

var PlayerType_value = map[string]int32{
	"HUMAN": 0,
	"ROBOT": 1,
}

func (x PlayerType) Enum() *PlayerType {
	p := new(PlayerType)
	*p = x
	return p
}

func (x PlayerType) String() string {
	return proto.EnumName(PlayerType_name, int32(x))
}

func (x *PlayerType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PlayerType_value, data, "PlayerType")
	if err != nil {
		return err
	}
	*x = PlayerType(value)
	return nil
}

func (PlayerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{1}
}

type Direction int32

const (
	Direction_UP    Direction = 1
	Direction_DOWN  Direction = 2
	Direction_LEFT  Direction = 3
	Direction_RIGHT Direction = 4
)

var Direction_name = map[int32]string{
	1: "UP",
	2: "DOWN",
	3: "LEFT",
	4: "RIGHT",
}

var Direction_value = map[string]int32{
	"UP":    1,
	"DOWN":  2,
	"LEFT":  3,
	"RIGHT": 4,
}

func (x Direction) Enum() *Direction {
	p := new(Direction)
	*p = x
	return p
}

func (x Direction) String() string {
	return proto.EnumName(Direction_name, int32(x))
}

func (x *Direction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Direction_value, data, "Direction")
	if err != nil {
		return err
	}
	*x = Direction(value)
	return nil
}

func (Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{2}
}

// Статус змеи в игре
type GameState_Snake_SnakeState int32

const (
	GameState_Snake_ALIVE  GameState_Snake_SnakeState = 0
	GameState_Snake_ZOMBIE GameState_Snake_SnakeState = 1
)

var GameState_Snake_SnakeState_name = map[int32]string{
	0: "ALIVE",
	1: "ZOMBIE",
}

var GameState_Snake_SnakeState_value = map[string]int32{
	"ALIVE":  0,
	"ZOMBIE": 1,
}

func (x GameState_Snake_SnakeState) Enum() *GameState_Snake_SnakeState {
	p := new(GameState_Snake_SnakeState)
	*p = x
	return p
}

func (x GameState_Snake_SnakeState) String() string {
	return proto.EnumName(GameState_Snake_SnakeState_name, int32(x))
}

func (x *GameState_Snake_SnakeState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GameState_Snake_SnakeState_value, data, "GameState_Snake_SnakeState")
	if err != nil {
		return err
	}
	*x = GameState_Snake_SnakeState(value)
	return nil
}

func (GameState_Snake_SnakeState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{3, 1, 0}
}

// Игрок
type GamePlayer struct {
	Name                 *string     `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Id                   *int32      `protobuf:"varint,2,req,name=id" json:"id,omitempty"`
	IpAddress            *string     `protobuf:"bytes,3,req,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	Port                 *int32      `protobuf:"varint,4,req,name=port" json:"port,omitempty"`
	Role                 *NodeRole   `protobuf:"varint,5,req,name=role,enum=snakes.NodeRole" json:"role,omitempty"`
	Type                 *PlayerType `protobuf:"varint,6,opt,name=type,enum=snakes.PlayerType,def=0" json:"type,omitempty"`
	Score                *int32      `protobuf:"varint,7,req,name=score" json:"score,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GamePlayer) Reset()         { *m = GamePlayer{} }
func (m *GamePlayer) String() string { return proto.CompactTextString(m) }
func (*GamePlayer) ProtoMessage()    {}
func (*GamePlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{0}
}
func (m *GamePlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GamePlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GamePlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GamePlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GamePlayer.Merge(m, src)
}
func (m *GamePlayer) XXX_Size() int {
	return m.Size()
}
func (m *GamePlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_GamePlayer.DiscardUnknown(m)
}

var xxx_messageInfo_GamePlayer proto.InternalMessageInfo

const Default_GamePlayer_Type PlayerType = PlayerType_HUMAN

func (m *GamePlayer) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *GamePlayer) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *GamePlayer) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *GamePlayer) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *GamePlayer) GetRole() NodeRole {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return NodeRole_NORMAL
}

func (m *GamePlayer) GetType() PlayerType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_GamePlayer_Type
}

func (m *GamePlayer) GetScore() int32 {
	if m != nil && m.Score != nil {
		return *m.Score
	}
	return 0
}

// Параметры идущей игры (не должны меняться в процессе игры)
type GameConfig struct {
	Width                *int32   `protobuf:"varint,1,opt,name=width,def=40" json:"width,omitempty"`
	Height               *int32   `protobuf:"varint,2,opt,name=height,def=30" json:"height,omitempty"`
	FoodStatic           *int32   `protobuf:"varint,3,opt,name=food_static,json=foodStatic,def=1" json:"food_static,omitempty"`
	FoodPerPlayer        *float32 `protobuf:"fixed32,4,opt,name=food_per_player,json=foodPerPlayer,def=1" json:"food_per_player,omitempty"`
	StateDelayMs         *int32   `protobuf:"varint,5,opt,name=state_delay_ms,json=stateDelayMs,def=1000" json:"state_delay_ms,omitempty"`
	DeadFoodProb         *float32 `protobuf:"fixed32,6,opt,name=dead_food_prob,json=deadFoodProb,def=0.1" json:"dead_food_prob,omitempty"`
	PingDelayMs          *int32   `protobuf:"varint,7,opt,name=ping_delay_ms,json=pingDelayMs,def=100" json:"ping_delay_ms,omitempty"`
	NodeTimeoutMs        *int32   `protobuf:"varint,8,opt,name=node_timeout_ms,json=nodeTimeoutMs,def=800" json:"node_timeout_ms,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameConfig) Reset()         { *m = GameConfig{} }
func (m *GameConfig) String() string { return proto.CompactTextString(m) }
func (*GameConfig) ProtoMessage()    {}
func (*GameConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{1}
}
func (m *GameConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameConfig.Merge(m, src)
}
func (m *GameConfig) XXX_Size() int {
	return m.Size()
}
func (m *GameConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GameConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GameConfig proto.InternalMessageInfo

const Default_GameConfig_Width int32 = 40
const Default_GameConfig_Height int32 = 30
const Default_GameConfig_FoodStatic int32 = 1
const Default_GameConfig_FoodPerPlayer float32 = 1
const Default_GameConfig_StateDelayMs int32 = 1000
const Default_GameConfig_DeadFoodProb float32 = 0.1
const Default_GameConfig_PingDelayMs int32 = 100
const Default_GameConfig_NodeTimeoutMs int32 = 800

func (m *GameConfig) GetWidth() int32 {
	if m != nil && m.Width != nil {
		return *m.Width
	}
	return Default_GameConfig_Width
}

func (m *GameConfig) GetHeight() int32 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return Default_GameConfig_Height
}

func (m *GameConfig) GetFoodStatic() int32 {
	if m != nil && m.FoodStatic != nil {
		return *m.FoodStatic
	}
	return Default_GameConfig_FoodStatic
}

func (m *GameConfig) GetFoodPerPlayer() float32 {
	if m != nil && m.FoodPerPlayer != nil {
		return *m.FoodPerPlayer
	}
	return Default_GameConfig_FoodPerPlayer
}

func (m *GameConfig) GetStateDelayMs() int32 {
	if m != nil && m.StateDelayMs != nil {
		return *m.StateDelayMs
	}
	return Default_GameConfig_StateDelayMs
}

func (m *GameConfig) GetDeadFoodProb() float32 {
	if m != nil && m.DeadFoodProb != nil {
		return *m.DeadFoodProb
	}
	return Default_GameConfig_DeadFoodProb
}

func (m *GameConfig) GetPingDelayMs() int32 {
	if m != nil && m.PingDelayMs != nil {
		return *m.PingDelayMs
	}
	return Default_GameConfig_PingDelayMs
}

func (m *GameConfig) GetNodeTimeoutMs() int32 {
	if m != nil && m.NodeTimeoutMs != nil {
		return *m.NodeTimeoutMs
	}
	return Default_GameConfig_NodeTimeoutMs
}

// Игроки конкретной игры
type GamePlayers struct {
	Players              []*GamePlayer `protobuf:"bytes,1,rep,name=players" json:"players,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GamePlayers) Reset()         { *m = GamePlayers{} }
func (m *GamePlayers) String() string { return proto.CompactTextString(m) }
func (*GamePlayers) ProtoMessage()    {}
func (*GamePlayers) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{2}
}
func (m *GamePlayers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GamePlayers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GamePlayers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GamePlayers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GamePlayers.Merge(m, src)
}
func (m *GamePlayers) XXX_Size() int {
	return m.Size()
}
func (m *GamePlayers) XXX_DiscardUnknown() {
	xxx_messageInfo_GamePlayers.DiscardUnknown(m)
}

var xxx_messageInfo_GamePlayers proto.InternalMessageInfo

func (m *GamePlayers) GetPlayers() []*GamePlayer {
	if m != nil {
		return m.Players
	}
	return nil
}

// Текущее состояние игрового поля
type GameState struct {
	StateOrder           *int32             `protobuf:"varint,1,req,name=state_order,json=stateOrder" json:"state_order,omitempty"`
	Snakes               []*GameState_Snake `protobuf:"bytes,2,rep,name=snakes" json:"snakes,omitempty"`
	Foods                []*GameState_Coord `protobuf:"bytes,3,rep,name=foods" json:"foods,omitempty"`
	Players              *GamePlayers       `protobuf:"bytes,4,req,name=players" json:"players,omitempty"`
	Config               *GameConfig        `protobuf:"bytes,5,req,name=config" json:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GameState) Reset()         { *m = GameState{} }
func (m *GameState) String() string { return proto.CompactTextString(m) }
func (*GameState) ProtoMessage()    {}
func (*GameState) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{3}
}
func (m *GameState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameState.Merge(m, src)
}
func (m *GameState) XXX_Size() int {
	return m.Size()
}
func (m *GameState) XXX_DiscardUnknown() {
	xxx_messageInfo_GameState.DiscardUnknown(m)
}

var xxx_messageInfo_GameState proto.InternalMessageInfo

func (m *GameState) GetStateOrder() int32 {
	if m != nil && m.StateOrder != nil {
		return *m.StateOrder
	}
	return 0
}

func (m *GameState) GetSnakes() []*GameState_Snake {
	if m != nil {
		return m.Snakes
	}
	return nil
}

func (m *GameState) GetFoods() []*GameState_Coord {
	if m != nil {
		return m.Foods
	}
	return nil
}

func (m *GameState) GetPlayers() *GamePlayers {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *GameState) GetConfig() *GameConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

// Координаты в пределах игрового поля, либо относительное смещение координат.
// Левая верхняя клетка поля имеет координаты (x=0, y=0).
// Направление смещения задаётся знаком чисел.
type GameState_Coord struct {
	X                    *int32   `protobuf:"zigzag32,1,opt,name=x,def=0" json:"x,omitempty"`
	Y                    *int32   `protobuf:"zigzag32,2,opt,name=y,def=0" json:"y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameState_Coord) Reset()         { *m = GameState_Coord{} }
func (m *GameState_Coord) String() string { return proto.CompactTextString(m) }
func (*GameState_Coord) ProtoMessage()    {}
func (*GameState_Coord) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{3, 0}
}
func (m *GameState_Coord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameState_Coord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameState_Coord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameState_Coord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameState_Coord.Merge(m, src)
}
func (m *GameState_Coord) XXX_Size() int {
	return m.Size()
}
func (m *GameState_Coord) XXX_DiscardUnknown() {
	xxx_messageInfo_GameState_Coord.DiscardUnknown(m)
}

var xxx_messageInfo_GameState_Coord proto.InternalMessageInfo

const Default_GameState_Coord_X int32 = 0
const Default_GameState_Coord_Y int32 = 0

func (m *GameState_Coord) GetX() int32 {
	if m != nil && m.X != nil {
		return *m.X
	}
	return Default_GameState_Coord_X
}

func (m *GameState_Coord) GetY() int32 {
	if m != nil && m.Y != nil {
		return *m.Y
	}
	return Default_GameState_Coord_Y
}

// Змея
type GameState_Snake struct {
	PlayerId *int32 `protobuf:"varint,1,req,name=player_id,json=playerId" json:"player_id,omitempty"`
	// Список "ключевых" точек змеи. Первая точка хранит координаты головы змеи.
	// Каждая следующая - смещение следующей "ключевой" точки относительно предыдущей,
	// в частности последняя точка хранит смещение хвоста змеи относительно предыдущей "ключевой" точки.
	Points               []*GameState_Coord          `protobuf:"bytes,2,rep,name=points" json:"points,omitempty"`
	State                *GameState_Snake_SnakeState `protobuf:"varint,3,req,name=state,enum=snakes.GameState_Snake_SnakeState,def=0" json:"state,omitempty"`
	HeadDirection        *Direction                  `protobuf:"varint,4,req,name=head_direction,json=headDirection,enum=snakes.Direction" json:"head_direction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *GameState_Snake) Reset()         { *m = GameState_Snake{} }
func (m *GameState_Snake) String() string { return proto.CompactTextString(m) }
func (*GameState_Snake) ProtoMessage()    {}
func (*GameState_Snake) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{3, 1}
}
func (m *GameState_Snake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameState_Snake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameState_Snake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameState_Snake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameState_Snake.Merge(m, src)
}
func (m *GameState_Snake) XXX_Size() int {
	return m.Size()
}
func (m *GameState_Snake) XXX_DiscardUnknown() {
	xxx_messageInfo_GameState_Snake.DiscardUnknown(m)
}

var xxx_messageInfo_GameState_Snake proto.InternalMessageInfo

const Default_GameState_Snake_State GameState_Snake_SnakeState = GameState_Snake_ALIVE

func (m *GameState_Snake) GetPlayerId() int32 {
	if m != nil && m.PlayerId != nil {
		return *m.PlayerId
	}
	return 0
}

func (m *GameState_Snake) GetPoints() []*GameState_Coord {
	if m != nil {
		return m.Points
	}
	return nil
}

func (m *GameState_Snake) GetState() GameState_Snake_SnakeState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return Default_GameState_Snake_State
}

func (m *GameState_Snake) GetHeadDirection() Direction {
	if m != nil && m.HeadDirection != nil {
		return *m.HeadDirection
	}
	return Direction_UP
}

// Общий формат любого сообщения
type GameMessage struct {
	MsgSeq     *int64 `protobuf:"varint,1,req,name=msg_seq,json=msgSeq" json:"msg_seq,omitempty"`
	SenderId   *int32 `protobuf:"varint,10,opt,name=sender_id,json=senderId" json:"sender_id,omitempty"`
	ReceiverId *int32 `protobuf:"varint,11,opt,name=receiver_id,json=receiverId" json:"receiver_id,omitempty"`
	// Тип сообщения
	//
	// Types that are valid to be assigned to Type:
	//	*GameMessage_Ping
	//	*GameMessage_Steer
	//	*GameMessage_Ack
	//	*GameMessage_State
	//	*GameMessage_Announcement
	//	*GameMessage_Join
	//	*GameMessage_Error
	//	*GameMessage_RoleChange
	Type                 isGameMessage_Type `protobuf_oneof:"Type"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GameMessage) Reset()         { *m = GameMessage{} }
func (m *GameMessage) String() string { return proto.CompactTextString(m) }
func (*GameMessage) ProtoMessage()    {}
func (*GameMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{4}
}
func (m *GameMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameMessage.Merge(m, src)
}
func (m *GameMessage) XXX_Size() int {
	return m.Size()
}
func (m *GameMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_GameMessage.DiscardUnknown(m)
}

var xxx_messageInfo_GameMessage proto.InternalMessageInfo

type isGameMessage_Type interface {
	isGameMessage_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GameMessage_Ping struct {
	Ping *GameMessage_PingMsg `protobuf:"bytes,2,opt,name=ping,oneof" json:"ping,omitempty"`
}
type GameMessage_Steer struct {
	Steer *GameMessage_SteerMsg `protobuf:"bytes,3,opt,name=steer,oneof" json:"steer,omitempty"`
}
type GameMessage_Ack struct {
	Ack *GameMessage_AckMsg `protobuf:"bytes,4,opt,name=ack,oneof" json:"ack,omitempty"`
}
type GameMessage_State struct {
	State *GameMessage_StateMsg `protobuf:"bytes,5,opt,name=state,oneof" json:"state,omitempty"`
}
type GameMessage_Announcement struct {
	Announcement *GameMessage_AnnouncementMsg `protobuf:"bytes,6,opt,name=announcement,oneof" json:"announcement,omitempty"`
}
type GameMessage_Join struct {
	Join *GameMessage_JoinMsg `protobuf:"bytes,7,opt,name=join,oneof" json:"join,omitempty"`
}
type GameMessage_Error struct {
	Error *GameMessage_ErrorMsg `protobuf:"bytes,8,opt,name=error,oneof" json:"error,omitempty"`
}
type GameMessage_RoleChange struct {
	RoleChange *GameMessage_RoleChangeMsg `protobuf:"bytes,9,opt,name=role_change,json=roleChange,oneof" json:"role_change,omitempty"`
}

func (*GameMessage_Ping) isGameMessage_Type()         {}
func (*GameMessage_Steer) isGameMessage_Type()        {}
func (*GameMessage_Ack) isGameMessage_Type()          {}
func (*GameMessage_State) isGameMessage_Type()        {}
func (*GameMessage_Announcement) isGameMessage_Type() {}
func (*GameMessage_Join) isGameMessage_Type()         {}
func (*GameMessage_Error) isGameMessage_Type()        {}
func (*GameMessage_RoleChange) isGameMessage_Type()   {}

func (m *GameMessage) GetType() isGameMessage_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *GameMessage) GetMsgSeq() int64 {
	if m != nil && m.MsgSeq != nil {
		return *m.MsgSeq
	}
	return 0
}

func (m *GameMessage) GetSenderId() int32 {
	if m != nil && m.SenderId != nil {
		return *m.SenderId
	}
	return 0
}

func (m *GameMessage) GetReceiverId() int32 {
	if m != nil && m.ReceiverId != nil {
		return *m.ReceiverId
	}
	return 0
}

func (m *GameMessage) GetPing() *GameMessage_PingMsg {
	if x, ok := m.GetType().(*GameMessage_Ping); ok {
		return x.Ping
	}
	return nil
}

func (m *GameMessage) GetSteer() *GameMessage_SteerMsg {
	if x, ok := m.GetType().(*GameMessage_Steer); ok {
		return x.Steer
	}
	return nil
}

func (m *GameMessage) GetAck() *GameMessage_AckMsg {
	if x, ok := m.GetType().(*GameMessage_Ack); ok {
		return x.Ack
	}
	return nil
}

func (m *GameMessage) GetState() *GameMessage_StateMsg {
	if x, ok := m.GetType().(*GameMessage_State); ok {
		return x.State
	}
	return nil
}

func (m *GameMessage) GetAnnouncement() *GameMessage_AnnouncementMsg {
	if x, ok := m.GetType().(*GameMessage_Announcement); ok {
		return x.Announcement
	}
	return nil
}

func (m *GameMessage) GetJoin() *GameMessage_JoinMsg {
	if x, ok := m.GetType().(*GameMessage_Join); ok {
		return x.Join
	}
	return nil
}

func (m *GameMessage) GetError() *GameMessage_ErrorMsg {
	if x, ok := m.GetType().(*GameMessage_Error); ok {
		return x.Error
	}
	return nil
}

func (m *GameMessage) GetRoleChange() *GameMessage_RoleChangeMsg {
	if x, ok := m.GetType().(*GameMessage_RoleChange); ok {
		return x.RoleChange
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GameMessage) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GameMessage_Ping)(nil),
		(*GameMessage_Steer)(nil),
		(*GameMessage_Ack)(nil),
		(*GameMessage_State)(nil),
		(*GameMessage_Announcement)(nil),
		(*GameMessage_Join)(nil),
		(*GameMessage_Error)(nil),
		(*GameMessage_RoleChange)(nil),
	}
}

// Ничего не меняем, просто говорим что мы живы с интервалом ping_delay_ms
type GameMessage_PingMsg struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameMessage_PingMsg) Reset()         { *m = GameMessage_PingMsg{} }
func (m *GameMessage_PingMsg) String() string { return proto.CompactTextString(m) }
func (*GameMessage_PingMsg) ProtoMessage()    {}
func (*GameMessage_PingMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{4, 0}
}
func (m *GameMessage_PingMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameMessage_PingMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameMessage_PingMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameMessage_PingMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameMessage_PingMsg.Merge(m, src)
}
func (m *GameMessage_PingMsg) XXX_Size() int {
	return m.Size()
}
func (m *GameMessage_PingMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_GameMessage_PingMsg.DiscardUnknown(m)
}

var xxx_messageInfo_GameMessage_PingMsg proto.InternalMessageInfo

// Не-центральный игрок просит повернуть голову змеи
type GameMessage_SteerMsg struct {
	Direction            *Direction `protobuf:"varint,1,req,name=direction,enum=snakes.Direction" json:"direction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GameMessage_SteerMsg) Reset()         { *m = GameMessage_SteerMsg{} }
func (m *GameMessage_SteerMsg) String() string { return proto.CompactTextString(m) }
func (*GameMessage_SteerMsg) ProtoMessage()    {}
func (*GameMessage_SteerMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{4, 1}
}
func (m *GameMessage_SteerMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameMessage_SteerMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameMessage_SteerMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameMessage_SteerMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameMessage_SteerMsg.Merge(m, src)
}
func (m *GameMessage_SteerMsg) XXX_Size() int {
	return m.Size()
}
func (m *GameMessage_SteerMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_GameMessage_SteerMsg.DiscardUnknown(m)
}

var xxx_messageInfo_GameMessage_SteerMsg proto.InternalMessageInfo

func (m *GameMessage_SteerMsg) GetDirection() Direction {
	if m != nil && m.Direction != nil {
		return *m.Direction
	}
	return Direction_UP
}

// Подтверждение сообщения с таким же seq
type GameMessage_AckMsg struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameMessage_AckMsg) Reset()         { *m = GameMessage_AckMsg{} }
func (m *GameMessage_AckMsg) String() string { return proto.CompactTextString(m) }
func (*GameMessage_AckMsg) ProtoMessage()    {}
func (*GameMessage_AckMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{4, 2}
}
func (m *GameMessage_AckMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameMessage_AckMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameMessage_AckMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameMessage_AckMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameMessage_AckMsg.Merge(m, src)
}
func (m *GameMessage_AckMsg) XXX_Size() int {
	return m.Size()
}
func (m *GameMessage_AckMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_GameMessage_AckMsg.DiscardUnknown(m)
}

var xxx_messageInfo_GameMessage_AckMsg proto.InternalMessageInfo

// Центральный узел сообщает отсальным игрокам состояние игры
type GameMessage_StateMsg struct {
	State                *GameState `protobuf:"bytes,1,req,name=state" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GameMessage_StateMsg) Reset()         { *m = GameMessage_StateMsg{} }
func (m *GameMessage_StateMsg) String() string { return proto.CompactTextString(m) }
func (*GameMessage_StateMsg) ProtoMessage()    {}
func (*GameMessage_StateMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{4, 3}
}
func (m *GameMessage_StateMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameMessage_StateMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameMessage_StateMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameMessage_StateMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameMessage_StateMsg.Merge(m, src)
}
func (m *GameMessage_StateMsg) XXX_Size() int {
	return m.Size()
}
func (m *GameMessage_StateMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_GameMessage_StateMsg.DiscardUnknown(m)
}

var xxx_messageInfo_GameMessage_StateMsg proto.InternalMessageInfo

func (m *GameMessage_StateMsg) GetState() *GameState {
	if m != nil {
		return m.State
	}
	return nil
}

// Уведомление об идущей игре, регулярно отправляется multicast-ом
type GameMessage_AnnouncementMsg struct {
	Players              *GamePlayers `protobuf:"bytes,1,req,name=players" json:"players,omitempty"`
	Config               *GameConfig  `protobuf:"bytes,2,req,name=config" json:"config,omitempty"`
	CanJoin              *bool        `protobuf:"varint,3,opt,name=can_join,json=canJoin,def=1" json:"can_join,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GameMessage_AnnouncementMsg) Reset()         { *m = GameMessage_AnnouncementMsg{} }
func (m *GameMessage_AnnouncementMsg) String() string { return proto.CompactTextString(m) }
func (*GameMessage_AnnouncementMsg) ProtoMessage()    {}
func (*GameMessage_AnnouncementMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{4, 4}
}
func (m *GameMessage_AnnouncementMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameMessage_AnnouncementMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameMessage_AnnouncementMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameMessage_AnnouncementMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameMessage_AnnouncementMsg.Merge(m, src)
}
func (m *GameMessage_AnnouncementMsg) XXX_Size() int {
	return m.Size()
}
func (m *GameMessage_AnnouncementMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_GameMessage_AnnouncementMsg.DiscardUnknown(m)
}

var xxx_messageInfo_GameMessage_AnnouncementMsg proto.InternalMessageInfo

const Default_GameMessage_AnnouncementMsg_CanJoin bool = true

func (m *GameMessage_AnnouncementMsg) GetPlayers() *GamePlayers {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *GameMessage_AnnouncementMsg) GetConfig() *GameConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *GameMessage_AnnouncementMsg) GetCanJoin() bool {
	if m != nil && m.CanJoin != nil {
		return *m.CanJoin
	}
	return Default_GameMessage_AnnouncementMsg_CanJoin
}

// Новый игрок хочет присоединиться к идущей игре
type GameMessage_JoinMsg struct {
	PlayerType           *PlayerType `protobuf:"varint,1,opt,name=player_type,json=playerType,enum=snakes.PlayerType,def=0" json:"player_type,omitempty"`
	OnlyView             *bool       `protobuf:"varint,2,opt,name=only_view,json=onlyView,def=0" json:"only_view,omitempty"`
	Name                 *string     `protobuf:"bytes,3,req,name=name" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GameMessage_JoinMsg) Reset()         { *m = GameMessage_JoinMsg{} }
func (m *GameMessage_JoinMsg) String() string { return proto.CompactTextString(m) }
func (*GameMessage_JoinMsg) ProtoMessage()    {}
func (*GameMessage_JoinMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{4, 5}
}
func (m *GameMessage_JoinMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameMessage_JoinMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameMessage_JoinMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameMessage_JoinMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameMessage_JoinMsg.Merge(m, src)
}
func (m *GameMessage_JoinMsg) XXX_Size() int {
	return m.Size()
}
func (m *GameMessage_JoinMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_GameMessage_JoinMsg.DiscardUnknown(m)
}

var xxx_messageInfo_GameMessage_JoinMsg proto.InternalMessageInfo

const Default_GameMessage_JoinMsg_PlayerType PlayerType = PlayerType_HUMAN
const Default_GameMessage_JoinMsg_OnlyView bool = false

func (m *GameMessage_JoinMsg) GetPlayerType() PlayerType {
	if m != nil && m.PlayerType != nil {
		return *m.PlayerType
	}
	return Default_GameMessage_JoinMsg_PlayerType
}

func (m *GameMessage_JoinMsg) GetOnlyView() bool {
	if m != nil && m.OnlyView != nil {
		return *m.OnlyView
	}
	return Default_GameMessage_JoinMsg_OnlyView
}

func (m *GameMessage_JoinMsg) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

// Ошибка операции (например отказ в присоединении к игре, т.к. нет места на поле)
type GameMessage_ErrorMsg struct {
	ErrorMessage         *string  `protobuf:"bytes,1,req,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameMessage_ErrorMsg) Reset()         { *m = GameMessage_ErrorMsg{} }
func (m *GameMessage_ErrorMsg) String() string { return proto.CompactTextString(m) }
func (*GameMessage_ErrorMsg) ProtoMessage()    {}
func (*GameMessage_ErrorMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{4, 6}
}
func (m *GameMessage_ErrorMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameMessage_ErrorMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameMessage_ErrorMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameMessage_ErrorMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameMessage_ErrorMsg.Merge(m, src)
}
func (m *GameMessage_ErrorMsg) XXX_Size() int {
	return m.Size()
}
func (m *GameMessage_ErrorMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_GameMessage_ErrorMsg.DiscardUnknown(m)
}

var xxx_messageInfo_GameMessage_ErrorMsg proto.InternalMessageInfo

func (m *GameMessage_ErrorMsg) GetErrorMessage() string {
	if m != nil && m.ErrorMessage != nil {
		return *m.ErrorMessage
	}
	return ""
}

// Сообщение о смене роли:
// 1. от заместителя другим игрокам о том, что пора начинать считать его главным (sender_role = MASTER)
// 2. от осознанно выходящего игрока (sender_role = VIEWER)
// 3. от главного к умершему игроку (receiver_role = VIEWER)
// 4. в комбинации с 1,2 или отдельно от них: назначение кого-то заместителем (receiver_role = DEPUTY)
// 5. в комбинации с 2 от главного узла заместителю о том, что он становится главным (receiver_role = MASTER)
type GameMessage_RoleChangeMsg struct {
	SenderRole           *NodeRole `protobuf:"varint,1,opt,name=sender_role,json=senderRole,enum=snakes.NodeRole" json:"sender_role,omitempty"`
	ReceiverRole         *NodeRole `protobuf:"varint,2,opt,name=receiver_role,json=receiverRole,enum=snakes.NodeRole" json:"receiver_role,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GameMessage_RoleChangeMsg) Reset()         { *m = GameMessage_RoleChangeMsg{} }
func (m *GameMessage_RoleChangeMsg) String() string { return proto.CompactTextString(m) }
func (*GameMessage_RoleChangeMsg) ProtoMessage()    {}
func (*GameMessage_RoleChangeMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a7c2e526a11cf97, []int{4, 7}
}
func (m *GameMessage_RoleChangeMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameMessage_RoleChangeMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameMessage_RoleChangeMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameMessage_RoleChangeMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameMessage_RoleChangeMsg.Merge(m, src)
}
func (m *GameMessage_RoleChangeMsg) XXX_Size() int {
	return m.Size()
}
func (m *GameMessage_RoleChangeMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_GameMessage_RoleChangeMsg.DiscardUnknown(m)
}

var xxx_messageInfo_GameMessage_RoleChangeMsg proto.InternalMessageInfo

func (m *GameMessage_RoleChangeMsg) GetSenderRole() NodeRole {
	if m != nil && m.SenderRole != nil {
		return *m.SenderRole
	}
	return NodeRole_NORMAL
}

func (m *GameMessage_RoleChangeMsg) GetReceiverRole() NodeRole {
	if m != nil && m.ReceiverRole != nil {
		return *m.ReceiverRole
	}
	return NodeRole_NORMAL
}

func init() {
	proto.RegisterEnum("snakes.NodeRole", NodeRole_name, NodeRole_value)
	proto.RegisterEnum("snakes.PlayerType", PlayerType_name, PlayerType_value)
	proto.RegisterEnum("snakes.Direction", Direction_name, Direction_value)
	proto.RegisterEnum("snakes.GameState_Snake_SnakeState", GameState_Snake_SnakeState_name, GameState_Snake_SnakeState_value)
	proto.RegisterType((*GamePlayer)(nil), "snakes.GamePlayer")
	proto.RegisterType((*GameConfig)(nil), "snakes.GameConfig")
	proto.RegisterType((*GamePlayers)(nil), "snakes.GamePlayers")
	proto.RegisterType((*GameState)(nil), "snakes.GameState")
	proto.RegisterType((*GameState_Coord)(nil), "snakes.GameState.Coord")
	proto.RegisterType((*GameState_Snake)(nil), "snakes.GameState.Snake")
	proto.RegisterType((*GameMessage)(nil), "snakes.GameMessage")
	proto.RegisterType((*GameMessage_PingMsg)(nil), "snakes.GameMessage.PingMsg")
	proto.RegisterType((*GameMessage_SteerMsg)(nil), "snakes.GameMessage.SteerMsg")
	proto.RegisterType((*GameMessage_AckMsg)(nil), "snakes.GameMessage.AckMsg")
	proto.RegisterType((*GameMessage_StateMsg)(nil), "snakes.GameMessage.StateMsg")
	proto.RegisterType((*GameMessage_AnnouncementMsg)(nil), "snakes.GameMessage.AnnouncementMsg")
	proto.RegisterType((*GameMessage_JoinMsg)(nil), "snakes.GameMessage.JoinMsg")
	proto.RegisterType((*GameMessage_ErrorMsg)(nil), "snakes.GameMessage.ErrorMsg")
	proto.RegisterType((*GameMessage_RoleChangeMsg)(nil), "snakes.GameMessage.RoleChangeMsg")
}

func init() { proto.RegisterFile("snakes.proto", fileDescriptor_5a7c2e526a11cf97) }

var fileDescriptor_5a7c2e526a11cf97 = []byte{
	// 1182 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x5f, 0x8f, 0xd3, 0x46,
	0x10, 0x67, 0x1d, 0x3b, 0x71, 0xc6, 0x49, 0xce, 0x6c, 0x2b, 0x61, 0x99, 0x16, 0xd2, 0x50, 0x89,
	0x70, 0x2d, 0x47, 0x2e, 0x50, 0x09, 0x85, 0x87, 0xea, 0x8e, 0x0b, 0x90, 0x8a, 0xdc, 0x9d, 0xf6,
	0x02, 0xa8, 0x7d, 0xb1, 0x4c, 0xbc, 0xe4, 0x5c, 0x2e, 0xde, 0x60, 0x9b, 0x3f, 0x79, 0xe8, 0x17,
	0xa8, 0xd4, 0xaf, 0xd4, 0xe7, 0x3e, 0x55, 0xfd, 0x08, 0x15, 0xdf, 0xa1, 0xea, 0x6b, 0x35, 0xb3,
	0x4e, 0x72, 0xc0, 0x05, 0xd4, 0x97, 0x68, 0x3d, 0xf3, 0x9b, 0xd9, 0xd9, 0xdf, 0xfc, 0x76, 0x36,
	0x50, 0xcb, 0x92, 0xf0, 0xb9, 0xcc, 0xb6, 0x66, 0xa9, 0xca, 0x15, 0x2f, 0xeb, 0xaf, 0xd6, 0x9f,
	0x0c, 0xe0, 0x7e, 0x38, 0x95, 0x87, 0x27, 0xe1, 0x5c, 0xa6, 0x9c, 0x83, 0x99, 0x84, 0x53, 0xe9,
	0xb1, 0xa6, 0xd1, 0xae, 0x0a, 0x5a, 0xf3, 0x06, 0x18, 0x71, 0xe4, 0x19, 0x4d, 0xa3, 0x6d, 0x09,
	0x23, 0x8e, 0xf8, 0x97, 0x00, 0xf1, 0x2c, 0x08, 0xa3, 0x28, 0x95, 0x59, 0xe6, 0x95, 0x08, 0x59,
	0x8d, 0x67, 0x3b, 0xda, 0x80, 0x29, 0x66, 0x2a, 0xcd, 0x3d, 0x93, 0x02, 0x68, 0xcd, 0xbf, 0x06,
	0x33, 0x55, 0x27, 0xd2, 0xb3, 0x9a, 0x46, 0xbb, 0xd1, 0x75, 0xb7, 0x8a, 0x52, 0xf6, 0x55, 0x24,
	0x85, 0x3a, 0x91, 0x82, 0xbc, 0xfc, 0x3a, 0x98, 0xf9, 0x7c, 0x26, 0xbd, 0x72, 0x93, 0xb5, 0x1b,
	0x5d, 0xbe, 0x40, 0xe9, 0xd2, 0x46, 0xf3, 0x99, 0xec, 0x59, 0x0f, 0x1e, 0x0d, 0x77, 0xf6, 0x05,
	0xc1, 0xf8, 0xe7, 0x60, 0x65, 0x63, 0x95, 0x4a, 0xaf, 0x42, 0x3b, 0xe9, 0x8f, 0xd6, 0xef, 0x86,
	0x3e, 0xd0, 0x5d, 0x95, 0x3c, 0x8b, 0x27, 0xdc, 0x03, 0xeb, 0x75, 0x1c, 0xe5, 0xc7, 0x1e, 0x6b,
	0xb2, 0xb6, 0xd5, 0x33, 0x6e, 0x75, 0x84, 0x36, 0x70, 0x1f, 0xca, 0xc7, 0x32, 0x9e, 0x1c, 0xe7,
	0x9e, 0xa1, 0x5d, 0x37, 0x3b, 0xa2, 0xb0, 0xf0, 0x16, 0x38, 0xcf, 0x94, 0x8a, 0x82, 0x2c, 0x0f,
	0xf3, 0x78, 0xec, 0x95, 0x08, 0xc0, 0xb6, 0x05, 0xa0, 0xf5, 0x88, 0x8c, 0xfc, 0x1a, 0x6c, 0x10,
	0x66, 0x26, 0xd3, 0x60, 0x46, 0x25, 0x7a, 0x66, 0x93, 0xb5, 0x0d, 0xc4, 0xd5, 0xd1, 0x73, 0x28,
	0xd3, 0x82, 0xd5, 0x4d, 0x68, 0x60, 0x26, 0x19, 0x44, 0xf2, 0x24, 0x9c, 0x07, 0xd3, 0xcc, 0xb3,
	0x28, 0xa3, 0xb9, 0xdd, 0xe9, 0x74, 0x44, 0x8d, 0x7c, 0x7b, 0xe8, 0x1a, 0x66, 0xfc, 0x1a, 0x34,
	0x22, 0x19, 0x46, 0x81, 0xce, 0x9d, 0xaa, 0xa7, 0x44, 0x87, 0xd1, 0x2b, 0x75, 0xb6, 0xb6, 0x45,
	0x0d, 0x5d, 0xf7, 0x30, 0x77, 0xaa, 0x9e, 0xf2, 0xab, 0x50, 0x9f, 0xc5, 0xc9, 0x64, 0x95, 0xb5,
	0x42, 0x59, 0x4b, 0xdb, 0x9d, 0x8e, 0x70, 0xd0, 0xb3, 0xc8, 0xf9, 0x0d, 0x6c, 0x24, 0x2a, 0x92,
	0x41, 0x1e, 0x4f, 0xa5, 0x7a, 0x99, 0x23, 0xd4, 0xd6, 0xd0, 0xdb, 0x9d, 0x8e, 0xa8, 0xa3, 0x6f,
	0xa4, 0x5d, 0xc3, 0xac, 0x75, 0x07, 0x9c, 0x95, 0x20, 0x32, 0xfe, 0x2d, 0x54, 0xf4, 0xe9, 0x32,
	0x8f, 0x35, 0x4b, 0x6d, 0x67, 0xd5, 0x97, 0x15, 0x4a, 0x2c, 0x20, 0xad, 0x5f, 0x4d, 0xa8, 0xa2,
	0x1d, 0x39, 0x92, 0xfc, 0x32, 0x38, 0xfa, 0xdc, 0x2a, 0x8d, 0x64, 0x4a, 0xa2, 0xb2, 0x04, 0x90,
	0xe9, 0x00, 0x2d, 0xfc, 0x06, 0x14, 0x3a, 0xf4, 0x0c, 0xca, 0x7d, 0xe1, 0x74, 0x6e, 0xca, 0xb1,
	0x75, 0x84, 0x06, 0x51, 0xc0, 0xf8, 0x75, 0xb0, 0x90, 0x18, 0x94, 0xdd, 0x1a, 0xfc, 0x5d, 0xa5,
	0xd2, 0x48, 0x68, 0x14, 0xbf, 0xbe, 0x2a, 0x1e, 0xe5, 0xe8, 0x74, 0x3f, 0xfb, 0xb0, 0xf8, 0x6c,
	0x59, 0x3d, 0xdf, 0x84, 0xf2, 0x98, 0x64, 0x43, 0x42, 0x7d, 0xef, 0xa8, 0x5a, 0x50, 0xa2, 0x40,
	0xf8, 0xd7, 0xc0, 0xa2, 0xad, 0xf8, 0x06, 0xb0, 0x37, 0xa4, 0xae, 0xf3, 0x3d, 0xd6, 0x11, 0xec,
	0x0d, 0x1a, 0xe6, 0xa4, 0x29, 0x6d, 0x98, 0xfb, 0xff, 0x30, 0xb0, 0xe8, 0x18, 0xfc, 0x22, 0x54,
	0xf5, 0x5e, 0x41, 0x1c, 0x15, 0x74, 0xd8, 0xda, 0x30, 0x88, 0x90, 0x8c, 0x99, 0x8a, 0x93, 0xfc,
	0x23, 0x64, 0xe8, 0xc3, 0x15, 0x30, 0xfe, 0x3d, 0x58, 0xc4, 0x25, 0xdd, 0xc1, 0x46, 0xb7, 0xb5,
	0x86, 0x3c, 0xfd, 0x4b, 0x86, 0x9e, 0xb5, 0xf3, 0x70, 0xf0, 0xb8, 0x2f, 0x74, 0x1c, 0xbf, 0x0d,
	0x8d, 0x63, 0xd4, 0x5a, 0x14, 0xa7, 0x72, 0x9c, 0xc7, 0x2a, 0x21, 0x96, 0x1a, 0xdd, 0xf3, 0x8b,
	0x4c, 0x7b, 0x0b, 0x87, 0xa8, 0x23, 0x70, 0xf9, 0xd9, 0xba, 0x02, 0xb0, 0xca, 0xca, 0xab, 0xa0,
	0xf3, 0xba, 0xe7, 0x38, 0x40, 0xf9, 0xa7, 0x83, 0xe1, 0xee, 0xa0, 0xef, 0xb2, 0xd6, 0xbf, 0xb6,
	0x96, 0xd2, 0x50, 0x66, 0x59, 0x38, 0x91, 0xfc, 0x02, 0x54, 0xa6, 0xd9, 0x24, 0xc8, 0xe4, 0x0b,
	0x3a, 0x7b, 0x49, 0x94, 0xa7, 0xd9, 0xe4, 0x48, 0xbe, 0x40, 0x5a, 0x32, 0x99, 0x44, 0x9a, 0x16,
	0x40, 0x65, 0x0a, 0x5b, 0x1b, 0x06, 0x11, 0x8a, 0x28, 0x95, 0x63, 0x19, 0xbf, 0xd2, 0x6e, 0x87,
	0xdc, 0xb0, 0x30, 0x0d, 0x22, 0xbe, 0x0d, 0x26, 0x8a, 0x9d, 0x28, 0x77, 0xba, 0x17, 0x4f, 0xb3,
	0x50, 0xec, 0xbc, 0x75, 0x18, 0x27, 0x93, 0x61, 0x36, 0x79, 0x70, 0x4e, 0x10, 0x94, 0xdf, 0x42,
	0xe6, 0xa4, 0x4c, 0xe9, 0x66, 0x3b, 0xdd, 0x2f, 0xce, 0x8a, 0x39, 0x42, 0x80, 0x0e, 0xd2, 0x60,
	0xbe, 0x05, 0xa5, 0x70, 0xfc, 0x9c, 0x6e, 0xb9, 0xd3, 0xf5, 0xcf, 0x8a, 0xd9, 0x19, 0x3f, 0xd7,
	0x11, 0x08, 0xd4, 0xbb, 0x60, 0x7f, 0xac, 0x8f, 0xed, 0x12, 0xe6, 0x72, 0xb9, 0x0b, 0x92, 0x39,
	0x80, 0x5a, 0x98, 0x24, 0xea, 0x65, 0x32, 0x96, 0x53, 0x99, 0xe4, 0x74, 0xfd, 0x9d, 0xee, 0x95,
	0x33, 0xb7, 0x3b, 0x85, 0xd3, 0x39, 0xde, 0x09, 0x45, 0x66, 0x7e, 0x56, 0x71, 0x42, 0x73, 0x61,
	0x0d, 0x33, 0x3f, 0xa8, 0x38, 0x29, 0x98, 0x41, 0x28, 0xd6, 0x2c, 0xd3, 0x54, 0xa5, 0x34, 0x20,
	0xd6, 0xd4, 0xdc, 0x47, 0x40, 0x51, 0x33, 0x81, 0xf9, 0x1e, 0x38, 0x38, 0xc1, 0x83, 0xf1, 0x71,
	0x98, 0x4c, 0xa4, 0x57, 0xa5, 0xd8, 0xaf, 0xce, 0x8a, 0xc5, 0x71, 0x7f, 0x97, 0x50, 0x3a, 0x01,
	0xa4, 0x4b, 0x83, 0x5f, 0x85, 0x4a, 0xd1, 0x28, 0xff, 0x0e, 0xd8, 0x0b, 0xfe, 0xf9, 0x0d, 0xa8,
	0xae, 0x04, 0xca, 0xd6, 0x09, 0x74, 0x85, 0xf1, 0x6d, 0x28, 0xeb, 0x46, 0xf8, 0x37, 0x31, 0x8d,
	0x26, 0x98, 0x5f, 0x5d, 0x74, 0x83, 0xd1, 0xdd, 0x3e, 0xff, 0xc1, 0x6d, 0x29, 0x1a, 0xe0, 0xff,
	0xc6, 0x60, 0xe3, 0x3d, 0x66, 0x4f, 0x0f, 0x12, 0xf6, 0xbf, 0x06, 0x89, 0xf1, 0xa9, 0x41, 0xc2,
	0x2f, 0x83, 0x3d, 0x0e, 0x93, 0x80, 0x1a, 0x85, 0x72, 0xb4, 0x7b, 0x66, 0x9e, 0xbe, 0x94, 0xa2,
	0x32, 0x0e, 0x13, 0xec, 0x8e, 0xff, 0x0b, 0x54, 0x8a, 0x2e, 0xf1, 0x1e, 0x38, 0xc5, 0xfc, 0xa0,
	0x87, 0x92, 0x7d, 0xea, 0xa1, 0x84, 0xd9, 0xd2, 0xc4, 0x5b, 0x50, 0x55, 0xc9, 0xc9, 0x3c, 0x78,
	0x15, 0xcb, 0xd7, 0x74, 0x57, 0xec, 0x9e, 0xf5, 0x2c, 0x3c, 0xc9, 0xa4, 0xb0, 0xd1, 0xfe, 0x38,
	0x96, 0xaf, 0x97, 0xcf, 0x7f, 0x69, 0xf5, 0xfc, 0xfb, 0x37, 0xc0, 0x5e, 0x34, 0x9c, 0x5f, 0x81,
	0x3a, 0x35, 0x3c, 0x98, 0xea, 0x76, 0x16, 0xff, 0x13, 0x6a, 0x64, 0x2c, 0x5a, 0xec, 0xcf, 0xa1,
	0xfe, 0x4e, 0x97, 0xf9, 0x36, 0x38, 0xc5, 0xf5, 0xa6, 0x3f, 0x01, 0xba, 0xea, 0x0f, 0xff, 0x04,
	0x80, 0x06, 0xe1, 0x9a, 0x7f, 0x07, 0xf5, 0xe5, 0xa5, 0xa7, 0x20, 0x63, 0x4d, 0x50, 0x6d, 0x01,
	0xc3, 0xaf, 0xdd, 0x32, 0x98, 0x78, 0xd6, 0xcd, 0x1e, 0xd8, 0x0b, 0x04, 0x4e, 0xa4, 0xfd, 0x03,
	0x31, 0xdc, 0x79, 0xa8, 0xa7, 0xd3, 0x70, 0xe7, 0x68, 0xd4, 0x17, 0x2e, 0xc3, 0xf5, 0x5e, 0xff,
	0xf0, 0xd1, 0xe8, 0x47, 0xd7, 0xc0, 0xf5, 0xe3, 0x41, 0xff, 0x49, 0x5f, 0xb8, 0xa5, 0xcd, 0x16,
	0xc0, 0x8a, 0x48, 0x1c, 0x6d, 0x44, 0xa5, 0x7b, 0x0e, 0x97, 0xe2, 0x60, 0xf7, 0x60, 0xe4, 0xb2,
	0xcd, 0x2e, 0x54, 0x97, 0xca, 0xe3, 0x65, 0x30, 0x1e, 0x1d, 0xba, 0x8c, 0xdb, 0x60, 0xee, 0x1d,
	0x3c, 0xd9, 0x77, 0x0d, 0x5c, 0x3d, 0xec, 0xdf, 0x1b, 0xb9, 0x25, 0x8a, 0x19, 0xdc, 0x7f, 0x30,
	0x72, 0xcd, 0xdd, 0xda, 0x1f, 0x6f, 0x2f, 0xb1, 0xbf, 0xde, 0x5e, 0x62, 0x7f, 0xbf, 0xbd, 0xc4,
	0xfe, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x29, 0x5d, 0x3a, 0x6a, 0x8e, 0x09, 0x00, 0x00,
}

func (m *GamePlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GamePlayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GamePlayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Score == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("score")
	} else {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.Score))
		i--
		dAtA[i] = 0x38
	}
	if m.Type != nil {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x30
	}
	if m.Role == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("role")
	} else {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.Role))
		i--
		dAtA[i] = 0x28
	}
	if m.Port == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("port")
	} else {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.Port))
		i--
		dAtA[i] = 0x20
	}
	if m.IpAddress == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ip_address")
	} else {
		i -= len(*m.IpAddress)
		copy(dAtA[i:], *m.IpAddress)
		i = encodeVarintSnakes(dAtA, i, uint64(len(*m.IpAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	} else {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Name == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	} else {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintSnakes(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GameConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NodeTimeoutMs != nil {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.NodeTimeoutMs))
		i--
		dAtA[i] = 0x40
	}
	if m.PingDelayMs != nil {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.PingDelayMs))
		i--
		dAtA[i] = 0x38
	}
	if m.DeadFoodProb != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.DeadFoodProb))))
		i--
		dAtA[i] = 0x35
	}
	if m.StateDelayMs != nil {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.StateDelayMs))
		i--
		dAtA[i] = 0x28
	}
	if m.FoodPerPlayer != nil {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.FoodPerPlayer))))
		i--
		dAtA[i] = 0x25
	}
	if m.FoodStatic != nil {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.FoodStatic))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != nil {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Width != nil {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.Width))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GamePlayers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GamePlayers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GamePlayers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Players) > 0 {
		for iNdEx := len(m.Players) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Players[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnakes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GameState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Config == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("config")
	} else {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnakes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Players == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("players")
	} else {
		{
			size, err := m.Players.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnakes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Foods) > 0 {
		for iNdEx := len(m.Foods) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Foods[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnakes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Snakes) > 0 {
		for iNdEx := len(m.Snakes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Snakes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnakes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.StateOrder == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("state_order")
	} else {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.StateOrder))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameState_Coord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameState_Coord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameState_Coord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Y != nil {
		i = encodeVarintSnakes(dAtA, i, uint64((uint32(*m.Y)<<1)^uint32((*m.Y>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.X != nil {
		i = encodeVarintSnakes(dAtA, i, uint64((uint32(*m.X)<<1)^uint32((*m.X>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameState_Snake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameState_Snake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameState_Snake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HeadDirection == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("head_direction")
	} else {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.HeadDirection))
		i--
		dAtA[i] = 0x20
	}
	if m.State == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("state")
	} else {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Points) > 0 {
		for iNdEx := len(m.Points) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Points[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSnakes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PlayerId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("player_id")
	} else {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReceiverId != nil {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.ReceiverId))
		i--
		dAtA[i] = 0x58
	}
	if m.SenderId != nil {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.SenderId))
		i--
		dAtA[i] = 0x50
	}
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MsgSeq == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("msg_seq")
	} else {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.MsgSeq))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameMessage_Ping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_Ping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ping != nil {
		{
			size, err := m.Ping.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnakes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GameMessage_Steer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_Steer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Steer != nil {
		{
			size, err := m.Steer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnakes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GameMessage_Ack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_Ack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ack != nil {
		{
			size, err := m.Ack.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnakes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GameMessage_State) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_State) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnakes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GameMessage_Announcement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_Announcement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Announcement != nil {
		{
			size, err := m.Announcement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnakes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *GameMessage_Join) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_Join) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Join != nil {
		{
			size, err := m.Join.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnakes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *GameMessage_Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnakes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *GameMessage_RoleChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_RoleChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RoleChange != nil {
		{
			size, err := m.RoleChange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnakes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *GameMessage_PingMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameMessage_PingMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_PingMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GameMessage_SteerMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameMessage_SteerMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_SteerMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Direction == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("direction")
	} else {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.Direction))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameMessage_AckMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameMessage_AckMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_AckMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GameMessage_StateMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameMessage_StateMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_StateMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("state")
	} else {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnakes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GameMessage_AnnouncementMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameMessage_AnnouncementMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_AnnouncementMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CanJoin != nil {
		i--
		if *m.CanJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Config == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("config")
	} else {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnakes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Players == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("players")
	} else {
		{
			size, err := m.Players.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSnakes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GameMessage_JoinMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameMessage_JoinMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_JoinMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Name == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	} else {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintSnakes(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OnlyView != nil {
		i--
		if *m.OnlyView {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerType != nil {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.PlayerType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameMessage_ErrorMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameMessage_ErrorMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_ErrorMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ErrorMessage == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("error_message")
	} else {
		i -= len(*m.ErrorMessage)
		copy(dAtA[i:], *m.ErrorMessage)
		i = encodeVarintSnakes(dAtA, i, uint64(len(*m.ErrorMessage)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GameMessage_RoleChangeMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameMessage_RoleChangeMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameMessage_RoleChangeMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReceiverRole != nil {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.ReceiverRole))
		i--
		dAtA[i] = 0x10
	}
	if m.SenderRole != nil {
		i = encodeVarintSnakes(dAtA, i, uint64(*m.SenderRole))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSnakes(dAtA []byte, offset int, v uint64) int {
	offset -= sovSnakes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GamePlayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovSnakes(uint64(l))
	}
	if m.Id != nil {
		n += 1 + sovSnakes(uint64(*m.Id))
	}
	if m.IpAddress != nil {
		l = len(*m.IpAddress)
		n += 1 + l + sovSnakes(uint64(l))
	}
	if m.Port != nil {
		n += 1 + sovSnakes(uint64(*m.Port))
	}
	if m.Role != nil {
		n += 1 + sovSnakes(uint64(*m.Role))
	}
	if m.Type != nil {
		n += 1 + sovSnakes(uint64(*m.Type))
	}
	if m.Score != nil {
		n += 1 + sovSnakes(uint64(*m.Score))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Width != nil {
		n += 1 + sovSnakes(uint64(*m.Width))
	}
	if m.Height != nil {
		n += 1 + sovSnakes(uint64(*m.Height))
	}
	if m.FoodStatic != nil {
		n += 1 + sovSnakes(uint64(*m.FoodStatic))
	}
	if m.FoodPerPlayer != nil {
		n += 5
	}
	if m.StateDelayMs != nil {
		n += 1 + sovSnakes(uint64(*m.StateDelayMs))
	}
	if m.DeadFoodProb != nil {
		n += 5
	}
	if m.PingDelayMs != nil {
		n += 1 + sovSnakes(uint64(*m.PingDelayMs))
	}
	if m.NodeTimeoutMs != nil {
		n += 1 + sovSnakes(uint64(*m.NodeTimeoutMs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GamePlayers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovSnakes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StateOrder != nil {
		n += 1 + sovSnakes(uint64(*m.StateOrder))
	}
	if len(m.Snakes) > 0 {
		for _, e := range m.Snakes {
			l = e.Size()
			n += 1 + l + sovSnakes(uint64(l))
		}
	}
	if len(m.Foods) > 0 {
		for _, e := range m.Foods {
			l = e.Size()
			n += 1 + l + sovSnakes(uint64(l))
		}
	}
	if m.Players != nil {
		l = m.Players.Size()
		n += 1 + l + sovSnakes(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovSnakes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameState_Coord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != nil {
		n += 1 + sozSnakes(uint64(*m.X))
	}
	if m.Y != nil {
		n += 1 + sozSnakes(uint64(*m.Y))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameState_Snake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != nil {
		n += 1 + sovSnakes(uint64(*m.PlayerId))
	}
	if len(m.Points) > 0 {
		for _, e := range m.Points {
			l = e.Size()
			n += 1 + l + sovSnakes(uint64(l))
		}
	}
	if m.State != nil {
		n += 1 + sovSnakes(uint64(*m.State))
	}
	if m.HeadDirection != nil {
		n += 1 + sovSnakes(uint64(*m.HeadDirection))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgSeq != nil {
		n += 1 + sovSnakes(uint64(*m.MsgSeq))
	}
	if m.Type != nil {
		n += m.Type.Size()
	}
	if m.SenderId != nil {
		n += 1 + sovSnakes(uint64(*m.SenderId))
	}
	if m.ReceiverId != nil {
		n += 1 + sovSnakes(uint64(*m.ReceiverId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameMessage_Ping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ping != nil {
		l = m.Ping.Size()
		n += 1 + l + sovSnakes(uint64(l))
	}
	return n
}
func (m *GameMessage_Steer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Steer != nil {
		l = m.Steer.Size()
		n += 1 + l + sovSnakes(uint64(l))
	}
	return n
}
func (m *GameMessage_Ack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ack != nil {
		l = m.Ack.Size()
		n += 1 + l + sovSnakes(uint64(l))
	}
	return n
}
func (m *GameMessage_State) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovSnakes(uint64(l))
	}
	return n
}
func (m *GameMessage_Announcement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Announcement != nil {
		l = m.Announcement.Size()
		n += 1 + l + sovSnakes(uint64(l))
	}
	return n
}
func (m *GameMessage_Join) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Join != nil {
		l = m.Join.Size()
		n += 1 + l + sovSnakes(uint64(l))
	}
	return n
}
func (m *GameMessage_Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovSnakes(uint64(l))
	}
	return n
}
func (m *GameMessage_RoleChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleChange != nil {
		l = m.RoleChange.Size()
		n += 1 + l + sovSnakes(uint64(l))
	}
	return n
}
func (m *GameMessage_PingMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameMessage_SteerMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Direction != nil {
		n += 1 + sovSnakes(uint64(*m.Direction))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameMessage_AckMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameMessage_StateMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovSnakes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameMessage_AnnouncementMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Players != nil {
		l = m.Players.Size()
		n += 1 + l + sovSnakes(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovSnakes(uint64(l))
	}
	if m.CanJoin != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameMessage_JoinMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerType != nil {
		n += 1 + sovSnakes(uint64(*m.PlayerType))
	}
	if m.OnlyView != nil {
		n += 2
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovSnakes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameMessage_ErrorMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrorMessage != nil {
		l = len(*m.ErrorMessage)
		n += 1 + l + sovSnakes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameMessage_RoleChangeMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SenderRole != nil {
		n += 1 + sovSnakes(uint64(*m.SenderRole))
	}
	if m.ReceiverRole != nil {
		n += 1 + sovSnakes(uint64(*m.ReceiverRole))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSnakes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSnakes(x uint64) (n int) {
	return sovSnakes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GamePlayer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GamePlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GamePlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IpAddress = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Port = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var v NodeRole
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= NodeRole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Role = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v PlayerType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= PlayerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Score = &v
			hasFields[0] |= uint64(0x00000020)
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ip_address")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("port")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("role")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("score")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Width = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Height = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoodStatic", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FoodStatic = &v
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoodPerPlayer", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.FoodPerPlayer = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateDelayMs", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StateDelayMs = &v
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadFoodProb", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.DeadFoodProb = &v2
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingDelayMs", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PingDelayMs = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeTimeoutMs", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodeTimeoutMs = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GamePlayers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GamePlayers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GamePlayers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &GamePlayer{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameState) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateOrder", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StateOrder = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snakes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snakes = append(m.Snakes, &GameState_Snake{})
			if err := m.Snakes[len(m.Snakes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Foods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Foods = append(m.Foods, &GameState_Coord{})
			if err := m.Foods[len(m.Foods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Players == nil {
				m.Players = &GamePlayers{}
			}
			if err := m.Players.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &GameConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("state_order")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("players")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("config")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameState_Coord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Coord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Coord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.X = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Y = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameState_Snake) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Points = append(m.Points, &GameState_Coord{})
			if err := m.Points[len(m.Points)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var v GameState_Snake_SnakeState
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= GameState_Snake_SnakeState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.State = &v
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadDirection", wireType)
			}
			var v Direction
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HeadDirection = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("player_id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("state")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("head_direction")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSeq", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MsgSeq = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GameMessage_PingMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &GameMessage_Ping{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GameMessage_SteerMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &GameMessage_Steer{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GameMessage_AckMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &GameMessage_Ack{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GameMessage_StateMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &GameMessage_State{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Announcement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GameMessage_AnnouncementMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &GameMessage_Announcement{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GameMessage_JoinMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &GameMessage_Join{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GameMessage_ErrorMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &GameMessage_Error{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GameMessage_RoleChangeMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &GameMessage_RoleChange{v}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SenderId = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiverId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReceiverId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("msg_seq")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameMessage_PingMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameMessage_SteerMsg) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SteerMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SteerMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var v Direction
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Direction = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("direction")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameMessage_AckMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AckMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AckMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameMessage_StateMsg) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &GameState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("state")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameMessage_AnnouncementMsg) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnouncementMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnouncementMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Players == nil {
				m.Players = &GamePlayers{}
			}
			if err := m.Players.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &GameConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CanJoin = &b
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("players")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("config")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameMessage_JoinMsg) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerType", wireType)
			}
			var v PlayerType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= PlayerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlayerType = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyView", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.OnlyView = &b
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameMessage_ErrorMsg) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnakes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSnakes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ErrorMessage = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("error_message")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameMessage_RoleChangeMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleChangeMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleChangeMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderRole", wireType)
			}
			var v NodeRole
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= NodeRole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SenderRole = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiverRole", wireType)
			}
			var v NodeRole
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= NodeRole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReceiverRole = &v
		default:
			iNdEx = preIndex
			skippy, err := skipSnakes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSnakes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSnakes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSnakes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSnakes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSnakes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSnakes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSnakes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSnakes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSnakes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSnakes = fmt.Errorf("proto: unexpected end of group")
)
